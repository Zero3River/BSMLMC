\section{BSML Semantics}\label{BSML Semantics}

Bilateral State-based Modal Logic (BSML) is a modal logic that employs \textit{team semantics} (also known as state-based semantics). It was introduced to account for \textit{Free Choice} (FC) inferences in natural language, where conjunctive meanings are unexpectedly derived from disjunctive sentences. For example, the sentence "You may go to the beach or to the cinema" typically implies that "You may go to the beach \textit{and} you may go to the cinema." BSML extends classical modal logic with a \textit{nonemptiness atom} (NE), which is true in a state if and only if the state is nonempty. This extension allows BSML to formalize the \textit{neglect-zero tendency}, a cognitive tendency to disregard structures that verify sentences by virtue of some empty configuration.





The syntax of BSML is defined over a set of propositional variables \(\text{Prop}\). The formulas of BSML are generated by the following grammar:

\[
\varphi ::= p \mid \bot \mid \neg \varphi \mid (\varphi \land \varphi) \mid (\varphi \lor \varphi) \mid \Diamond \varphi \mid \text{NE}
\]

where \(p \in \text{Prop}\). The classical modal logic (ML) is the NE-free fragment of BSML.

The semantics of BSML is based on \textit{team semantics}, where formulas are interpreted with respect to sets of possible worlds (called \textit{states}) rather than single worlds. A \textit{model} \(M\) is a triple \((W, R, V)\), where:
\begin{itemize}
    \item \(W\) is a nonempty set of possible worlds,
    \item \(R \subseteq W \times W\) is an accessibility relation,
    \item \(V: \text{Prop} \to \mathcal{P}(W)\) is a valuation function.
\end{itemize}

A \textit{state} \(s\) is a subset of \(W\). The support and anti-support conditions for BSML formulas are defined recursively as follows:

\begin{align*}
M, s &\models p \quad \text{iff} \quad \forall w \in s, w \in V(p) \\
M, s &\leftmodels p \quad \text{iff} \quad \forall w \in s, w \notin V(p) \\
M, s &\models \bot \quad \text{iff} \quad s = \emptyset \\
M, s &\leftmodels \bot \quad \text{always} \\
M, s &\models \text{NE} \quad \text{iff} \quad s \neq \emptyset \\
M, s &\leftmodels  \text{NE} \quad \text{iff} \quad s = \emptyset \\
M, s &\models \neg \varphi \quad \text{iff} \quad M, s \leftmodels \varphi \\
M, s &\leftmodels  \neg \varphi \quad \text{iff} \quad M, s \models \varphi \\
M, s &\models \varphi \land \psi \quad \text{iff} \quad M, s \models \varphi \text{ and } M, s \models \psi \\
M, s &\leftmodels  \varphi \land \psi \quad \text{iff} \quad \exists t, u \subseteq s \text{ s.t. } s = t \cup u \text{ and } M, t \leftmodels \varphi \text{ and } M, u \leftmodels \psi \\
M, s &\models \varphi \lor \psi \quad \text{iff} \quad \exists t, u \subseteq s \text{ s.t. } s = t \cup u \text{ and } M, t \models \varphi \text{ and } M, u \models \psi \\
M, s &\leftmodels \varphi \lor \psi \quad \text{iff} \quad M, s \leftmodels \varphi \text{ and } M, s \leftmodels \psi \\
M, s &\models \varphi \inqdisj \psi \quad \text{iff} M, s \models \varphi \text{ or } M, s \models \psi \\
M, s &\leftmodels \varphi \inqdisj \psi \quad \text{iff} M, s \leftmodels\varphi \text{ and } M, s \leftmodels \psi\\
M, s &\models \Diamond \varphi \quad \text{iff} \quad \forall w \in s, \exists t \subseteq R[w] \text{ s.t. } t \neq \emptyset \text{ and } M, t \models \varphi \\
M, s &\leftmodels  \Diamond \varphi \quad \text{iff} \quad \forall w \in s, M, R[w] \leftmodels \varphi
\end{align*}